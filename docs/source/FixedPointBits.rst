..  currentmodule:: fixedpoint.fixedpoint

..  _FixedPoint_slicingandmapping:

###############################################################################
The **FixedPointBits** Class
###############################################################################

..  admonition:: Examples are just a click away
    :class: example

    Boxes like this link to example code.

..  class:: FixedPointBits

        ``FixedPointBits`` inherits from :class:`int` and adds item (square
        bracket)  access. You should not need to instantiate this, but this
        allows for :attr:`fixedpoint.FixedPoint.bits` to be
        :ref:`indexed <FixedPointBits_indexing>`,
        :ref:`sliced <FixedPointBits_slicing>`, and
        :ref:`mapped <FixedPointBits_mapping>`.

    ..  attribute:: s

        :type:
            |bool|_

        :value:
            *True* for signed, *False* for unsigned.

    ..  attribute:: m

        :type:
            |int|_

        :value:
            Number of integer bits.

    ..  attribute:: n

        :type:
            |int|_

        :value:
            Number of fractional bits.

    ..  method:: __getitem__(key)

        ..  note::

            This is the built-in square bracket ``[]`` operator.

        :param key:
            Bit index, slice, or mapping

        :type key:
            int or slice or str

        :rtype:
            int or str

        :raises KeyError:
            Unsupported mapping string

        :raises IndexError:
            Invalid slice step or index out of range

        The square brackets allow access to one or more bits at a time. No
        matter the access scheme (indexing, slicing, or mapping, described
        below), the return value is always shifted to be no more than *N* bits,
        where *N* is the number of bits accessed. E.g., accessing 3 bits will
        return an integer in the range [0, 2\ :sup:`3`), regardless of
        where they are located in the :class:`FixedPointBits`.

        ..  _FixedPointBits_indexing:

        ..  rubric:: Indexing

        When **key** is an :class:`int`, a single bit is accessed in
        :attr:`fixedpoint.FixedPoint.bits`. Index 0 is the LSb and index
        :attr:`~.FixedPointBits.m`\ +:attr:`~.FixedPointBits.n`\ -1 is the MSb.

        ..  admonition:: Jump to Examples
            :class: example

            - :ref:`single_bit_slice`

        ..  _FixedPointBits_slicing:

        ..  rubric:: Slicing

        When **key** is a :class:`slice` (either an explicit slice object, or
        generated by using one or more colons), one or more bits can be
        accessed. With ``bits`` as :class:`FixedPointBits` and ``A``, ``B``,
        and ``C`` as :class:`int` such that ``A`` > ``B``:

        - ``bits[A:B:C]`` returns bits ``A`` down to ``B`` (inclusive) with
          index 0 being the LSb and
          :attr:`~.FixedPointBits.m`\ +\ :attr:`~.FixedPointBits.n`\ -1 being the
          MSb. ``C`` can be omitted, but must be -1 if specified.
        - ``bits[B:A:C]`` returns bits ``A`` up to ``B`` (inclusive) with index
          0 being the MSb and
          :attr:`~.FixedPointBits.m`\ +\ :attr:`~.FixedPointBits.n`\ -1 being the
          LSb. ``C`` can be omitted, but must be 1 if specified.
        - ``bits[A:A:C]`` with ``C`` == -1 returns bit ``A`` within index 0
          being the LSb and
          :attr:`~.FixedPointBits.m`\ +\ :attr:`~.FixedPointBits.n`\ -1 being the
          MSb.
        - ``bits[B:B:C]`` with ``C`` == 1 returns bit ``B`` within index 0
          being the MSb and
          :attr:`~.FixedPointBits.m`\ +\ :attr:`~.FixedPointBits.n`\ -1 being the
          LSb.

        Any slicing format not specified above treats the
        :class:`FixedPointBits` as a binary digit :class:`str`
        (indexed from 0 to
        :attr:`~.FixedPointBits.m`\ +\ :attr:`~.FixedPointBits.n`\ -1).

        ..  admonition:: Jump to Examples
            :class: example

            - :ref:`multi_bit_slice`

        ..  _FixedPointBits_mapping:

        ..  rubric:: Mapping

        Common bit slices are mapped to string keywords:

        +------------+-----------------------+-------------------------------+
        | Key String |       Bit Slice       | Assumptions                   |
        +============+=======================+===============================+
        | ``'m'``    |                       |                               |
        +------------+ integer bits only     | :attr:`.FixedPointBits.m` > 0 |
        | ``'int'``  |                       |                               |
        +------------+-----------------------+-------------------------------+
        | ``'n'``    |                       |                               |
        +------------+ fractional bits only  | :attr:`.FixedPointBits.n` > 0 |
        | ``'frac'`` |                       |                               |
        +------------+-----------------------+-------------------------------+
        | ``'s'``    |                       |                               |
        +------------+                       | :attr:`.FixedPointBits.s`     |
        | ``'sign'`` | most significant bit  | is *True*                     |
        +------------+                       +-------------------------------+
        | ``'msb'``  |                       |                               |
        +------------+-----------------------+ --                            |
        | ``'lsb'``  | least significant bit |                               |
        +------------+-----------------------+-------------------------------+

        If the mapping is accessed and the assumption(s) for that mapping are
        not satisfied, a :exc:`KeyError` is raised.

        When the key string is **UPPERCASED**, the return value is a
        :class:`str` of binary bits (not an :class:`int`).

        ..  admonition:: Jump to Examples
            :class: example

            - :ref:`bit_mapping`
